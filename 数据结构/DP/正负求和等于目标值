
求和问题往往接近于Knapsack问题。就是每个元素的取舍
dp[i][s]  求和为S利用前i个数的路径数。
dp[i][s] = dp[i-1][s-nums[i-1]] + dp[i+1][s+nums[i-1]]
时间复杂度 O(n*S)
基本关系逻辑和暴力法一样，只不过暴力法重复计算，不保存结果。这里DP就是用空间换时间
为了使索引变得可能，对所有的索引加上总和Sum

public int findTargetSumWays(int[] nums, int S) {
      
      int sum = 0;
      for(int n: nums){
        sum += n;
      }
      if (S < -sum || S > sum) { return 0;}
        
      int[][] dp = new int[nums.length + 1][ 2 * sum + 1];
      dp[0][0 + sum] = 1; // 0 + sum means 0, 0 means -sum,  check below graph
      for(int i = 1; i <= nums.length; i++){
        for(int j = 0; j < 2 * sum + 1; j++){
          
          if(j + nums[i - 1] < 2  * sum + 1) dp[i][j] += dp[i - 1][j + nums[i - 1]];
          if(j - nums[i - 1] >= 0) dp[i][j] += dp[i - 1][j - nums[i - 1]];
        }
      }
      return dp[nums.length][sum + S];
    }
